// Copyright Shareef Jalloq
// SPDX-License-Identifier: MIT
//
// Auto-generated by peakrdl-sv
<%
  from systemrdl.rdltypes import OnReadType, OnWriteType

  lblock = block.inst_name.lower()
  ublock = block.inst_name.upper()

  addr_width = block.addrwidth
  data_width = block.accesswidth
  registers  = block.get_registers()
  num_regs   = len(registers)
  max_regs_char = len("{}".format(num_regs-1))

%>

module ${lblock} 
  import rdl_subreg_pkg::*;
#(
  parameter reset_type_e ResetType = ActiveHighSync
) (
  input logic clk,
  input logic rst,

  // Bus I/F 
  // REVISIT: hacked to the Migen CSR bus for now.
  input logic csr_we,
  input logic csr_re,
  input logic [6:0] csr_addr,
  input logic [7:0] csr_wdata,
  output logic [7:0] csr_rdata,

  // HW I/F
  output ${lblock}_reg_pkg::${lblock}_reg2hw_t reg2hw, // Write
  input  ${lblock}_reg_pkg::${lblock}_hw2reg_t hw2reg  // Read

);

  import ${lblock}_reg_pkg::*;

  localparam int AW  = ${addr_width};
  localparam int DW  = ${data_width};
  localparam int DBW = DW/8;

  // --------------------------------------------------------------------------------
  // Logic Declarations
  // --------------------------------------------------------------------------------

  logic           reg_we;
  logic           reg_re;
  logic [AW-1:0]  reg_addr;
  logic [DW-1:0]  reg_wdata;
  logic [DBW-1:0] reg_wstrb;
  logic [DW-1:0]  reg_rdata;

  
  // --------------------------------------------------------------------------------
  // REVISIT: temporary hack
  // --------------------------------------------------------------------------------

  assign reg_we    = csr_we;
  assign reg_re    = csr_re;
  assign reg_addr  = csr_addr;
  assign reg_wdata = csr_wdata;
  assign reg_wstrb = '1;
  assign csr_rdata = reg_rdata;


  // --------------------------------------------------------------------------------
  // Software Logic Declarations
  // --------------------------------------------------------------------------------

  % for r in registers:
  % if r.has_sw_writable:
  logic ${r.path.lower()}_we;
  % for f in r:
  logic ${sv_bitarray(f)} ${f.path.lower()}_wd;
  % endfor
  % endif
  % endfor

  // --------------------------------------------------------------------------------
  // Field Logic
  // --------------------------------------------------------------------------------

  % for i,r in enumerate(registers):
  % for f in r:
<%

  if len(r) == 1:
    struct_path = f"{r.path}"
  else:
    struct_path = f"{r.path}.{f.inst_name}"

  if f.is_sw_writable:
    we_expr = f"{r.path.lower()}_we"
    wd_expr = f"{f.path.lower()}_wd"
  else:
    we_expr = ""
    wd_expr = ""

  if f.is_sw_readable:
    qs_expr = f"{f.path}_qs"
  else:
    qs_expr = ""

  if f.is_hw_writable:
    de_expr = f"hw2reg.{struct_path}.de"
    d_expr  = f"hw2reg.{struct_path}.d"
  else:
    de_expr = "'0"
    d_expr = "'0"

  if f.swacc:
    qe_expr = f"reg2hw.{struct_path}.qe"
  else:
    qe_expr = ""

  if f.is_hw_readable:
    q_expr = f"reg2hw.{struct_path}.q"
  else:
    q_expr = ""

%>\
  // Field[${f.name}] ${f.bits}
  % if f.is_sw_readable:
  logic ${sv_bitarray(f)} ${qs_expr};
  % endif
  rdl_subreg #(
    .DW         (${f.width}),
    .ResetType  (ResetType),
    .ResetValue (${reset_gen(f)}),
    .OnRead     (${onread_gen(f)}),
    .OnWrite    (${onwrite_gen(f)})
  ) u_${f.path.lower()} (
    .clk (clk),
    .rst (rst),
    .we  (${we_expr}),
    .wd  (${wd_expr}),
    .de  (${de_expr}),
    .d   (${d_expr}),
    .qs  (${qs_expr}),
    .qe  (${qe_expr}),
    .q   (${q_expr})
  );

  % endfor
  % endfor

  // --------------------------------------------------------------------------------
  // Address Decode
  // --------------------------------------------------------------------------------

  logic [${num_regs-1}:0] addr_hit;
  always_comb begin
    addr_hit = '0;
    % for i,r in enumerate(registers):
    addr_hit[${"{}".format(i).rjust(max_regs_char)}] = (reg_addr == ${ublock}_${r.path.upper()}_OFFSET);
    % endfor
  end
  
  // --------------------------------------------------------------------------------
  // Write Enables
  // --------------------------------------------------------------------------------

  % for i,r in enumerate(registers):
${reg_enable_gen(r,i)}\
  % if len(r) == 1:
${field_wd_gen(r[0])}\
  % else:
    % for f in r:
${field_wd_gen(f)}\
    % endfor
  % endif
  
  % endfor

  // --------------------------------------------------------------------------------
  // Read Data Mux
  // --------------------------------------------------------------------------------

  always_comb begin
    reg_rdata = '0;
    unique case (1'b1)
  % for i, r in enumerate(registers):
    % if len(r) == 1:
      addr_hit[${i}]: begin
${rdata_gen(r[0])}\
      end

    % else:
      addr_hit[${i}]: begin
      % for f in r:
${rdata_gen(f)}\
      % endfor
      end

    % endif
  % endfor
      default: begin
        reg_rdata = 'X;
      end
    endcase
  end      

endmodule
<%def name="reg_enable_gen(reg, idx)">\
  % if reg.has_sw_writable:
  assign ${reg.path.lower()}_we = addr_hit[${idx}] && reg_we;
  % endif
  ## % if reg.has_sw_readable:
  ## assign ${reg.path.lower()}_re = addr_hit[${idx}] && reg_re;
  ## % endif
</%def>\
<%def name="field_wd_gen(field)">\
  % if field.is_sw_writable:
  assign ${field.path.lower()}_wd = reg_wdata[${field.bits}];
  % endif
</%def>\
<%def name="rdata_gen(field, rd_name='reg_rdata')">\
% if field.is_sw_readable:
        ${rd_name}[${field.bits}] = ${field.path.lower()}_qs;
% else:
        ${rd_name}[${field.bits}] = '0;
% endif
</%def>\
<%def name="onwrite_gen(field)" filter="trim">\
  % if field.onwrite == None:
OnWriteNone
  % elif isinstance(field.onwrite, OnWriteType.woset):
OnWriteWoset
  % elif isinstance(field.onwrite, OnWriteType.woclr):
OnWriteWoclr
  % elif isinstance(field.onwrite, OnWriteType.wot):
OnWriteWot
  % elif isinstance(field.onwrite, OnWriteType.wzs):
OnWriteWzs
  % elif isinstance(field.onwrite, OnWriteType.wzc):
OnWriteWzc
  % elif isinstance(field.onwrite, OnWriteType.wzt):
OnWriteWzt
  % elif isinstance(field.onwrite, OnWriteType.wclr):
OnWriteWclr
  % elif isinstance(field.onwrite, OnWriteType.wset):
OnWriteWset
  % endif
</%def>\
<%def name="onread_gen(field)" filter="trim">\
OnReadNone
</%def>\
<%def name="reset_gen(field)" filter="trim">\
${field.width}'d${field.reset or 0}
</%def>\
<%def name="sv_bitarray(field)" filter="trim">\
% if field.width > 1:
[${field.width-1}:0]
% endif
</%def>\
